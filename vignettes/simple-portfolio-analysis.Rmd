---
title: "simple-portfolio-analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simple-portfolio-analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(trisk.analysis)
library(dplyr)
```

# Run TRISK on a simple portfolio

This vignette shows how to use `run_trisk_on_simple_portfolio()` with a minimal
portfolio schema:

- `company_id`
- `company_name`
- `exposure_value_usd`
- `term`
- `loss_given_default`

Compared to `run_trisk_on_portfolio()`, no `country_iso2` column is required.

## Load model inputs

```{r}
assets_testdata <- read.csv(system.file("testdata", "assets_testdata.csv", package = "trisk.model", mustWork = TRUE))
scenarios_testdata <- read.csv(system.file("testdata", "scenarios_testdata.csv", package = "trisk.model", mustWork = TRUE))
financial_features_testdata <- read.csv(system.file("testdata", "financial_features_testdata.csv", package = "trisk.model", mustWork = TRUE))
ngfs_carbon_price_testdata <- read.csv(system.file("testdata", "ngfs_carbon_price_testdata.csv", package = "trisk.model", mustWork = TRUE))
```

## Load simple portfolio input

```{r}
simple_portfolio <- read.csv(
  system.file("testdata", "simple_portfolio.csv", package = "trisk.analysis", mustWork = TRUE)
)
simple_portfolio
```

## Run the model

```{r}
baseline_scenario <- "NGFS2023GCAM_CP"
target_scenario <- "NGFS2023GCAM_NZ2050"
scenario_geography <- "Global"

simple_results <- run_trisk_on_simple_portfolio(
  assets_data = assets_testdata,
  scenarios_data = scenarios_testdata,
  financial_data = financial_features_testdata,
  carbon_data = ngfs_carbon_price_testdata,
  portfolio_data = simple_portfolio,
  baseline_scenario = baseline_scenario,
  target_scenario = target_scenario,
  scenario_geography = scenario_geography
)

portfolio_results_tech_detail <- simple_results$portfolio_results_tech_detail
portfolio_results <- simple_results$portfolio_results
```

## NPV-based exposure allocation

`run_trisk_on_simple_portfolio()` adds `exposure_value_usd_share`, computed from
baseline NPV shares at company/sector/technology level:

1. compute baseline NPV share per run;
2. allocate exposure with that share;
3. average after dropping `run_id`;
4. re-scale so exposure totals match the original portfolio exposure.

```{r}
portfolio_results_tech_detail |>
  dplyr::select(
    company_id, term, sector, technology,
    exposure_value_usd_share,
    net_present_value_baseline
  ) |>
  utils::head(10)
```

Because `exposure_value_usd_share` is computed after dropping `run_id`, it is
constant across runs for a given `(company_id, term, sector, technology)`.

```{r}
exposure_share_check <- portfolio_results_tech_detail |>
  dplyr::distinct(
    company_id, term, sector, technology,
    exposure_value_usd_share
  ) |>
  dplyr::group_by(company_id, term) |>
  dplyr::summarise(allocated_exposure = sum(exposure_value_usd_share, na.rm = TRUE), .groups = "drop") |>
  dplyr::left_join(
    portfolio_results |>
      dplyr::group_by(company_id, term) |>
      dplyr::summarise(original_exposure = sum(exposure_value_usd, na.rm = TRUE), .groups = "drop"),
    by = c("company_id", "term")
  ) |>
  dplyr::mutate(gap = allocated_exposure - original_exposure)

exposure_share_check
```

In the last table, `gap` should be close to zero (floating-point tolerance).
